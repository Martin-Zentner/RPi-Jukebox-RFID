#!/usr/bin/env python3

import logging
import os
import subprocess
import time
import re
import signal

from Reader import Reader

# ===============================================================================
# MOD0 START: additional imports, SETTINGS and initialization
# ===============================================================================
import paho.mqtt.client as mqtt
import ssl, datetime

# ----------------------------------------------------------
#  SETTINGS
# ----------------------------------------------------------
DEBUG = False
mqttBaseTopic = ""             # MQTT base topic
mqttClientId = ""              # MQTT client ID
mqttHostname = ""                # MQTT server hostname
mqttPort = 8883                         # MQTT server port (typically 1883 for unencrypted, 8883 for encrypted)
mqttUsername = ""                       # username for user/pass based authentication
mqttPassword = ""                       # password for user/pass based authentication
mqttCA = "/home/pi/MQTT/mqtt-ca.crt"    # path to server certificate for certificate-based authentication
mqttCert = "/home/pi/MQTT/mqtt-client-phoniebox.crt"    # path to client certificate for certificate-based authentication
mqttKey = "/home/pi/MQTT/mqtt-client-phoniebox.key"     # path to client keyfile for certificate-based authentication
mqttConnectionTimeout = 60              # in seconds; timeout for MQTT connection

useFastPublish = 0                   # set to 0 to disable new fast publish modification

# ----------------------------------------------------------
#  DO NOT CHANGE BELOW
# ----------------------------------------------------------

def on_connect(client, userdata, flags, rc):
    if rc == 0:
        print("Connection established.")
        client.publish(mqttBaseTopic + "/state", payload="online", qos=1, retain=True)
    else:
        print("Connection could NOT be established. Return-Code:", rc)

def on_disconnect(client, userdata, rc):
    print("Disconnecting. Return-Code:", str(rc))
    client.loop_stop()

def on_log(client, userdata, level, buf):
    print("   [LOG]", buf)

def on_message(client, userdata, message):
    print("")
    print("MQTT message incoming to subscriptions...")
    print(" - topic =", message.topic)
    print(" - value =", message.payload.decode("utf-8"))
    print("... We are not handling incoming messages")

if useFastPublish:
    # create client instance
    client = mqtt.Client(mqttClientId)

    # configure authentication
    if mqttUsername != "" and mqttPassword != "":
        client.username_pw_set(username=mqttUsername, password=mqttPassword)

    if mqttCert != "" and mqttKey != "":
        if mqttCA != "":
            client.tls_set(ca_certs=mqttCA, certfile=mqttCert, keyfile=mqttKey)
        else:
            client.tls_set(certfile=mqttCert, keyfile=mqttKey)
    elif mqttCA != "":
        client.tls_set(ca_certs=mqttCA)

    # attach event handlers
    client.on_connect = on_connect
    client.on_disconnect = on_disconnect
    client.on_message = on_message
    if DEBUG is True:
        client.on_log = on_log

    # define last will
    client.will_set(mqttBaseTopic + "/state", payload="offline", qos=1, retain=True)

    # connect to MQTT server
    print("Connecting to " + mqttHostname + " on port " + str(mqttPort))
    client.connect(mqttHostname, mqttPort, mqttConnectionTimeout)
# ===============================================================================
# MOD0 END
# ===============================================================================

logger = logging.getLogger()
logger.setLevel(logging.DEBUG)
ch = logging.StreamHandler()
ch.setLevel(logging.INFO)
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
ch.setFormatter(formatter)
logger.addHandler(ch)

reader = Reader()

# get absolute path of this script
dir_path = os.path.dirname(os.path.realpath(__file__))
logger.info('Dir_PATH: {dir_path}'.format(dir_path=dir_path))

# get control card ids
file_path = os.path.dirname(__file__)
if file_path != "":
    os.chdir(file_path)

# vars for ensuring delay between same-card-swipes
ssp = open('../settings/Second_Swipe_Pause', 'r')
same_id_delay = ssp.read().strip()
sspc = open('../settings/Second_Swipe_Pause_Controls', 'r')
sspc_nodelay = sspc.readline().strip()
previous_id = ""
previous_time = time.time()

# get swipe or place configuration value
sop = open('../settings/Swipe_or_Place', 'r')
swipe_or_place = sop.read().strip()

# create array for control card ids
cards = []

# open file and read the content in a list
with open('../settings/global.conf', 'r') as filehandle:
    filecontents = filehandle.readlines()

    for line in filecontents:
        cids = line[:-1]
        cards.append(cids)


extract = [s for s in cards if s.startswith('CMD')]
string = ''.join(extract)

# if controlcards delay is deactivated, let the cards pass, otherwise, they have to wait...
if sspc_nodelay == "ON":
    ids = re.findall("(\d+)", string)
else:
    ids = ""


# handler for RFID reading no cardid
def handler(signum, frame):
    logger.info('No RFID Signal detected.')
    try:
        # force pause the player script
        logger.info('Trigger Pause Force')
        subprocess.call([dir_path + '/playout_controls.sh -c=playerpauseforce -v=0.1'], shell=True)
    except OSError as e:
        logger.info('Execution of Pause failed.')


# associate the handler to signal alarm
signal.signal(signal.SIGALRM, handler)

# ===============================================================================
# MODI START
# ===============================================================================
if useFastPublish:
# start endless loop
    client.loop_start()
# ===============================================================================
# MODI END
# ===============================================================================

while True:
    # slow down the card reading while loop
    time.sleep(0.2)

    if swipe_or_place == "PLACENOTSWIPE":
        # enable the signal alarm (if no card is present for 1 second)
        signal.alarm(1)

    # reading the card id
    # NOTE: it's been reported that KKMOON Reader might need the following line altered.
    # Instead of:
    # cardid = reader.reader.readCard()
    # change the line to:
    # cardid = reader.readCard()
    # See here for (German ;) details:
    # https://github.com/MiczFlor/RPi-Jukebox-RFID/issues/551
    cardid = reader.reader.readCard()

    # disable the alarm after a successful read
    signal.alarm(0)

    try:
        # start the player script and pass on the cardid (but only if new card or otherwise
        # "same_id_delay" seconds have passed)
        if cardid is not None:
            if cardid != previous_id or (time.time() - previous_time) >= float(same_id_delay) or cardid in str(ids):

# ===============================================================================
# MODII START : immediately publish new cardid via MQTT
# ===============================================================================
                if useFastPublish:
                    # publish cardid
                    client.publish(mqttBaseTopic + "/attribute/new_card", payload=cardid)
                    print(" --> Publishing new cardid " + cardid)
# ===============================================================================
# MODII END
# ===============================================================================

                logger.info('Trigger Play Cardid={cardid}'.format(cardid=cardid))
                subprocess.call([dir_path + '/rfid_trigger_play.sh --cardid=' + cardid], shell=True)
                previous_id = cardid

            else:
                logger.debug('Ignoring Card id {cardid} due to same-card-delay, delay: {same_id_delay}'.format(
                    cardid=cardid,
                    same_id_delay=same_id_delay
                ))

            previous_time = time.time()

    except OSError as e:
        logger.error('Execution failed: {e}'.format(e=e))
